I"[.<p>I made myself a promise a couple of months ago. My next app would be fully unit tested for the non-UI components and fully instrument-tested for the UI components. That’s a tall order, especially since I’m using the latest and greatest Android Studio Canary. I ran into a few problems. Some can’t be solved and some can.</p>

<p>Let’s start with a simple test. I’ve got a class that looks this:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="kd">data class</span> <span class="nc">Note</span><span class="p">(</span><span class="kd">val</span> <span class="py">id</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="n">UUID</span><span class="p">.</span><span class="n">randomUUID</span><span class="p">().</span><span class="n">toString</span><span class="p">())</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="py">updated</span><span class="p">:</span> <span class="n">Long</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span>
    <span class="k">private</span> <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span> <span class="n">field</span> <span class="p">=</span> <span class="n">value</span> <span class="p">}</span>
  <span class="kd">var</span> <span class="py">title</span><span class="p">:</span> <span class="n">String</span> <span class="p">=</span> <span class="s">""</span>
    <span class="k">set</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">updated</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">currentTimeMillis</span><span class="p">()</span>
      <span class="n">field</span> <span class="p">=</span> <span class="n">value</span>
    <span class="p">}</span>
  <span class="c1">// Some more fields here</span>
  <span class="n">init</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">isBlank</span><span class="p">())</span> <span class="k">throw</span> <span class="n">IllegalArgumentException</span><span class="p">()</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>This is a fairly simple model class, but I wanted to ensure that the updated property was automatically updated when I set the title. So I wrote a unit test:</p>

<figure class="highlight"><pre><code class="language-kotlin" data-lang="kotlin"><span class="k">package</span> <span class="nn">com.amazonaws.mobile.samples.mynotes.models</span>

<span class="k">import</span> <span class="nn">org.junit.Test</span>
<span class="k">import</span> <span class="nn">org.junit.Assert.*</span>
<span class="kd">class</span> <span class="nc">NoteUnitTests</span> <span class="p">{</span>
  <span class="nd">@Test</span>
  <span class="k">fun</span> <span class="err">`</span><span class="nf">setting</span> <span class="n">the</span> <span class="n">title</span> <span class="n">sets</span> <span class="n">the</span> <span class="n">updated</span> <span class="n">date</span><span class="err">`</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">note</span> <span class="p">=</span> <span class="n">Note</span><span class="p">()</span>
    <span class="kd">val</span> <span class="py">updated</span> <span class="p">=</span> <span class="n">note</span><span class="p">.</span><span class="n">updated</span>
    <span class="n">Thread</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="m">100L</span><span class="p">)</span>
    <span class="n">note</span><span class="p">.</span><span class="n">title</span> <span class="p">=</span> <span class="s">"test"</span>
    <span class="n">assertNotSame</span><span class="p">(</span><span class="s">"T10-1"</span><span class="p">,</span> <span class="n">updated</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">updated</span><span class="p">)</span>
    <span class="n">assertTrue</span><span class="p">(</span><span class="s">"T10-2"</span><span class="p">,</span> <span class="n">note</span><span class="p">.</span><span class="n">updated</span> <span class="p">&gt;</span> <span class="n">updated</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>It’s in among some 21 tests each with a few assertions to check. The assertion message is just unique to the assert so that I can find it in larger test suites.</p>

<p>Good things:</p>

<ul>
  <li>Note how I can name the test something reasonable. I love this feature. You can’t use dots or other special characters in the function name, but pretty much anything else goes. This is also how it is reported.</li>
  <li>I can right-click on the unit test and run-debug and get the test results, set breakpoints, etc.</li>
</ul>

<p>Ok, that’s good, but there are a lot of bad things.</p>

<h2 id="configuring-junit-5">Configuring JUnit 5</h2>

<p>Firstly, I wanted to switch to JUnit 5, which came out in 2016. Yep — that’s over 2 years ago. There still isn’t a standard way to just pick JUnit 5. What are they waiting for over in Android Studio land?</p>

<p>Fortunately, community members have stepped up. Here is how you get Android Studio (and your project) to use JUnit 5. First, edit the top-level <code class="highlighter-rouge">build.gradle</code> file and add the following classpath (with the others):</p>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="n">classpath</span> <span class="s2">"de.mannodermaus.gradle.plugins:android-junit5:1.0.32"</span></code></pre></figure>

<p>This is a plugin for JUnit5 that really aids in setup. Now, edit your app <code class="highlighter-rouge">build.gradle</code> file. Add the following plugin at the top:</p>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="n">apply</span> <span class="nl">plugin:</span> <span class="s2">"de.mannodermaus.android-junit5"</span></code></pre></figure>

<p>Then remove the existing test implementations and add these ones instead:</p>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="c1">// Testing</span>
<span class="n">testImplementation</span> <span class="n">junit5</span><span class="o">.</span><span class="na">unitTests</span><span class="o">()</span>
<span class="n">testImplementation</span> <span class="n">junit5</span><span class="o">.</span><span class="na">parameterized</span><span class="o">()</span>
<span class="n">androidTestImplementation</span> <span class="n">junit5</span><span class="o">.</span><span class="na">instrumentationTests</span><span class="o">()</span></code></pre></figure>

<p>Finally, make sure you set up JDK 1.8. While you are editing the app <code class="highlighter-rouge">build.gradle</code>, add the following to the android closure:</p>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="n">compileOptions</span> <span class="o">{</span>
    <span class="n">sourceCompatibility</span> <span class="n">JavaVersion</span><span class="o">.</span><span class="na">VERSION_1_8</span>
    <span class="n">targetCompatibility</span> <span class="n">JavaVersion</span><span class="o">.</span><span class="na">VERSION_1_8</span>
<span class="o">}</span></code></pre></figure>

<p>Then change the Kotlin dependency to this:</p>

<figure class="highlight"><pre><code class="language-gradle" data-lang="gradle"><span class="c1">// Kotlin</span>
<span class="n">implementation</span> <span class="s2">"org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"</span></code></pre></figure>

<p>Clean and rebuild. Your unit and instrumented tests will now be using JUnit 5 as the test runner. This is in large part due to the work of Marcel Schnelle, who wrote the plugin. The instructions are on his GitHub repository.</p>

<p>JUnit 5 isn’t a big deal in Android development. JUnit 4 works just fine, thank you. However, JUnit5 includes support for JDK 1.8. A lot of people write their tests in Java (more on why in a moment), so you may want to write Java lambda expressions, as an example. You also get tagging, disabled tests, better exception testing, and much more. For a good overview of the new features, see <a href="http://www.baeldung.com/junit-5-preview">this article on baeldung.com</a>.</p>

<h2 id="the-problems">The problems</h2>

<p>So, what’s not so great:</p>

<ul>
  <li>Android Studio Canary has a bug (say it ain’t so!) that prevents code coverage from running within the UI. Various people have suggested fixes for this on Stack Overflow. However, all the suggested remedies have failed me.</li>
  <li>You can’t run all the tests in the app from the UI. That means you don’t get the nice IDE-driven pass/fail test with debug/run and breakpoints. If you run all the tests, do it from the terminal with <code class="highlighter-rouge">./gradlew test</code>.</li>
  <li>When you run a single package (or directory) worth of tests, the IDE generates a new configuration. That causes a proliferation of configurations (one for each class you run individually plus one for each package).</li>
  <li>When the tests finish, the task does not stop. If you go over to the stop button, you may notice several tasks running — one for each test run you ran. They don’t stop when you click Stop All either. You have to restart the IDE.</li>
  <li>It looks (and feels) like there is a major memory leak in the IDE functionality associated with testing. I’ve noticed that I regularly run out of memory (despite increases) when I am in the process of writing code with TDD (where I write the tests first then write the code and continually run the tests until all the tests pass). Again, shutting down and restarting the IDE seems to be the only way to fix this.</li>
</ul>

<p>Android Studio Canary is bleeding edge, so these things will happen. It’s definitely not a polished product yet. However, if you are writing Kotlin apps, you need to be on Canary as that is where all the good stuff is happening on a regular basis.</p>

<h2 id="wrap-up">Wrap up</h2>

<p>Despite these setbacks, I am now finding writing tests before the code is starting to be second nature and I have much more confidence in the code I am writing. My general process is:</p>

<ul>
  <li>Sit down and think and write a rough specification.</li>
  <li>Write the tests to exercise the specification.</li>
  <li>Write stubs for the code.</li>
  <li>Run the tests from the command line — yay! everything fails!</li>
  <li>Start writing the code, augmenting the tests where I feel it’s a good idea to catch edge cases. (Don’t reduce the number of tests — always increase)</li>
  <li>Run the tests again, potentially with debug to step through the code to see where I’ve been an idiot.</li>
  <li>Repeat the last two steps as often as is required.</li>
</ul>

<p>I wrote my first class (the data model for my app) before the tests and before I had thought about what I wanted to do with it. It didn’t work out too well, so I had to delete it, write the spec and then the tests.</p>

<p>Don’t let the problems with Android Studio prevent you from testing. Get in the habit of unit testing your code even for the simple projects. It will make you a better coder. I know it has improved my coding ability.</p>

<!-- AWS Links -->

<!-- Consoles -->

<!-- My Links -->

:ET