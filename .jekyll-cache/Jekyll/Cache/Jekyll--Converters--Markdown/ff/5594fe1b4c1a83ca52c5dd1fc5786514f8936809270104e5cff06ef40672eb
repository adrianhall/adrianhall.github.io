I"cU<p><a href="https://aws.amazon.com/appsync">AWS AppSync</a> is a managed <a href="https://graphql.org/learn">GraphQL</a> service that can (and probably should) act as the data layer for your app. I’m not going to go into the details of how to configure it since I’ve gone through that in excruciating detail recently (see blog <a href="/cloud/2018/11/15/restaurant-reviews/">#1</a>, <a href="/cloud/2018/11/30/restaurant-reviews-part-2/">#2</a>, <a href="/cloud/2018/12/06/restaurant-reviews-part-3/">#3</a>, and <a href="/cloud/2018/12/10/restaurant-reviews-part-4/">#4</a>). Rather, I want to take a look at how you can send a query to AWS AppSync from your React (or React Native) app.</p>

<p>You have three basic choices:</p>
<ul>
  <li>Include a query within a component using <a href="https://aws-amplify.github.io?utm_source=da&amp;utm_medium=blog&amp;utm_campaign=adrianha">AWS Amplify</a>.</li>
  <li>Wrap your query in the Connect component using AWS Amplify.</li>
  <li>Use the <a href="https://www.apollographql.com/docs/react/">Apollo Client</a> with the AWS AppSync SDK.</li>
</ul>

<p>Which do you choose depends on what your needs are. There is no “one size fits all”.</p>

<p>Let’s look at the options:</p>

<h2 id="include-a-query-within-a-component-using-awsamplify">Include a query within a component using AWS Amplify</h2>

<p>The first version of the query utilizes the <code class="highlighter-rouge">API.graphql()</code> method from the <a href="https://aws-amplify.github.io/docs/js/api#amplify-graphql-client">AWS Amplify library</a>. You can execute queries, mutations, and subscriptions from this form. It’s an async network call, so expect to deal with promises and errors. Here is the canonical form of a simple query:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kr">public</span> <span class="k">async</span> <span class="nx">componentWillMount</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">API</span><span class="p">.</span><span class="nx">graphql</span><span class="p">(</span><span class="nx">graphqlOperation</span><span class="p">(</span><span class="dl">'</span><span class="s1">{ me { id name } }</span><span class="dl">'</span><span class="p">));</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">componentWillMount: result = </span><span class="dl">'</span><span class="p">,</span> <span class="nx">result</span><span class="p">);</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">loading</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">data</span><span class="p">:</span> <span class="nx">result</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">me</span> <span class="p">});</span>
        <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span> <span class="na">loading</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">errors</span><span class="p">:</span> <span class="p">[</span> <span class="nx">err</span><span class="p">.</span><span class="nx">message</span> <span class="p">]</span> <span class="p">});</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>There are a couple of notes here:</p>

<ol>
  <li>I’m using async/await to ensure I wait for the data.</li>
  <li>I must use try/catch so that I can catch network and authentication errors.</li>
  <li>
    <p>The result has a data block with the fields that I requested:</p>

    <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nx">result</span> <span class="o">=</span> <span class="nb">Object</span> <span class="p">{</span>
   <span class="dl">"</span><span class="s2">data</span><span class="dl">"</span><span class="p">:</span> <span class="nb">Object</span> <span class="p">{</span>
     <span class="dl">"</span><span class="s2">me</span><span class="dl">"</span><span class="p">:</span> <span class="nb">Object</span> <span class="p">{</span>
       <span class="dl">"</span><span class="s2">id</span><span class="dl">"</span><span class="p">:</span> <span class="dl">"</span><span class="s2">ARO*****:CognitoIdentityCredentials</span><span class="dl">"</span><span class="p">,</span>
       <span class="dl">"</span><span class="s2">name</span><span class="dl">"</span><span class="p">:</span> <span class="kc">null</span>
     <span class="p">}</span>
   <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>All the fields you requested are returned, but the value may be null if no data is available.  If I’ve got a component that has to get data from the network or I am using a library to do all the calls (and mocking those calls for testability), this is a great way to do it. However, if I decide to incorporate the call within a component, I have to worry about how I am going to test that component. I’d more likely place the call within a library and swap out the library with a mocked call at that point.</p>

<p>I also have to deal with online/offline capabilities. The AWS Amplify library does not do offline at this point in time, so if I want that functionality, I’m going to have to go to a different library.</p>

<p>Pros:</p>
<ul>
  <li>It’s simple to set up an execute the query, mutation, or subscription.</li>
  <li>It works with the AWS Amplify CLI and configuration file, so configuration is a snap.</li>
  <li>It works easily with my preferred Flux implementation.</li>
  <li>Simplified codebase = less stuff to go wrong.</li>
</ul>

<p>Cons:</p>
<ul>
  <li>You will need to be careful to ensure that your components can be unit tested.</li>
  <li>There is no offline capabilities.</li>
</ul>

<h2 id="wrap-your-query-in-the-aws-amplify-connect-component">Wrap your query in the AWS Amplify Connect component</h2>

<p>The next step is to use the <a href="https://aws-amplify.github.io/docs/js/api#amplify-graphql-client"><code class="highlighter-rouge">&lt;Connect&gt;</code> component</a> to wrap my component. The <code class="highlighter-rouge">&lt;Connect&gt;</code> component will give you loading and error conditions, so you can use those to handle network conditions. Let’s say I have a component that is normally used like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">UserBlock</span> <span class="nx">name</span><span class="o">=</span><span class="p">{</span><span class="dl">"</span><span class="s2">Adrian Hall</span><span class="dl">"</span><span class="p">}</span><span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p>I want to use the <a href="https://aws-amplify.github.io/docs/js/api#connect"><code class="highlighter-rouge">&lt;Connect&gt;</code> query</a> to connect this to the me query that I was using before. I might do this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">UserBlockFunction</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">Connect</span> <span class="nx">query</span><span class="o">=</span><span class="p">{</span><span class="nx">graphqlOperation</span><span class="p">(</span><span class="dl">'</span><span class="s1">{ me { id name } }</span><span class="dl">'</span><span class="p">)}</span><span class="o">&gt;</span>
            <span class="p">{(</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">loading</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">LoadingIndicator</span> <span class="nx">loading</span><span class="o">=</span><span class="p">{</span><span class="nx">response</span><span class="p">.</span><span class="nx">loading</span><span class="p">}</span><span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span>                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span> <span class="o">&amp;&amp;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">me</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">UserBlock</span> <span class="nx">name</span><span class="o">=</span><span class="p">{</span><span class="nx">response</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">me</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span>                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">ErrorIndicator</span> <span class="nx">errors</span><span class="o">=</span><span class="p">{</span><span class="nx">response</span><span class="p">.</span><span class="nx">errors</span><span class="p">}</span><span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span>                <span class="p">}</span>
            <span class="p">}}</span>
        <span class="o">&lt;</span><span class="sr">/Connect</span><span class="err">&gt;
</span>    <span class="p">);</span>
<span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">UserBlockFunction</span><span class="p">;</span>
</code></pre></div></div>

<p>In this version, I’ve got three cases:</p>
<ol>
  <li>The query is loading (loading == true)</li>
  <li>The query has returned data (response.data.me is defined)</li>
  <li>The query ended in one or more errors (response.errors is defined)</li>
</ol>

<p>I can use this to generate different output within my exported function for each condition.  I generally have the underlying components as one set of files, then I connect them to the GraphQL API as another set of files.</p>

<p>Pros:</p>
<ul>
  <li>I can test my underlying components individually without resorting to network connectivity.</li>
  <li>I can hook individual parts of my component hierarchy as needed, resulting in much flexibility.</li>
  <li>The API is powerful, yet simple. That leads to elegant and readable code that is easy to debug.</li>
</ul>

<p>Cons:</p>
<ul>
  <li>It no longer works with my Flux configuration, so I now have two state systems to deal with.</li>
  <li>Still no offline support.</li>
</ul>

<h2 id="use-the-apollo-client-with-the-aws-appsyncsdk">Use the Apollo Client with the AWS AppSync SDK.</h2>

<p>The final method is to bring in a heavyweight client like the Apollo Client. It took me some time to learn the Apollo Client and it’s overkill for most situations. </p>

<p>In this method, you create an AWS AppSync Client, then use that to configure the Apollo Client. Then wrap your entire app within the Apollo Client. Your connected components now have full knowledge of the Apollo Client, but your lower level components can remain oblivious (just like the <code class="highlighter-rouge">&lt;Connect&gt;</code> component I discussed above). Let’s look at the same functionality as before. First, configure the client within your main app code:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">gql</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">graphql-tag</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">AWSAppSyncClient</span><span class="p">,</span> <span class="p">{</span> <span class="nx">AUTH_TYPE</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">aws-appsync</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">aws_config</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./aws-exports</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">App</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./src/App</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">client</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AWSAppSyncClient</span><span class="p">({</span>
  <span class="na">url</span><span class="p">:</span> <span class="nx">aws_config</span><span class="p">.</span><span class="nx">aws_appsync_graphqlEndpoint</span><span class="p">,</span>
  <span class="na">region</span><span class="p">:</span> <span class="nx">aws_config</span><span class="p">.</span><span class="nx">aws_appsync_region</span><span class="p">,</span>
  <span class="na">auth</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="nx">aws_config</span><span class="p">.</span><span class="nx">aws_appsync_authenticationType</span><span class="p">,</span>
    <span class="na">apiKey</span><span class="p">:</span> <span class="nx">aws_config</span><span class="p">.</span><span class="nx">aws_appsync_apiKey</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">WithProvider</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">ApolloProvider</span> <span class="nx">client</span><span class="o">=</span><span class="p">{</span><span class="nx">client</span><span class="p">}</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">Rehydrated</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">App</span> <span class="o">/&gt;</span>
    <span class="o">&lt;</span><span class="sr">/Rehydrated</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/ApolloProvider</span><span class="err">&gt;
</span><span class="p">);</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">WithProvider</span><span class="p">;</span>
</code></pre></div></div>

<p>Then create the connected component:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">gql</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">graphql-tag</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">graphql</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react-apollo</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">UserBlockComponent</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">../components/UserBlock</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">gql</span><span class="s2">`
  query me {
    me { id name }
  }
`</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">UserBlock</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">loading</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">LoadingIndicator</span><span class="o">/&gt;</span><span class="p">):</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">props</span><span class="p">.</span><span class="nx">errors</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">ErrorIndicator</span> <span class="nx">errors</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">errors</span><span class="p">}</span><span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span>    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">UserBlockComponent</span> <span class="nx">name</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span><span class="sr">/&gt;</span><span class="se">)</span><span class="err">;
</span>    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">export</span> <span class="k">default</span> <span class="nx">graphql</span><span class="p">(</span><span class="nx">query</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">options</span><span class="p">:</span> <span class="p">{</span> 
    <span class="na">fetchPolicy</span><span class="p">:</span> <span class="dl">'</span><span class="s1">cache-and-network</span><span class="dl">'</span>
  <span class="p">},</span>
  <span class="na">props</span><span class="p">:</span> <span class="nx">props</span> <span class="o">=&gt;</span> <span class="p">({</span>
    <span class="na">loading</span><span class="p">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">loading</span><span class="p">,</span>
    <span class="na">errors</span><span class="p">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">errors</span><span class="p">,</span>
    <span class="na">name</span><span class="p">:</span> <span class="nx">props</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">me</span><span class="p">.</span><span class="nx">name</span> <span class="o">||</span> <span class="dl">'</span><span class="s1">undefined</span><span class="dl">'</span>
  <span class="p">})</span>
<span class="p">})(</span><span class="nx">UserBlock</span><span class="p">);</span>
</code></pre></div></div>

<p>More power, but more complexity and more places for things to go wrong.</p>

<p>Pros:</p>
<ul>
  <li>Offline capabilities are available. Queries are cached and mutations are queued for later transmission</li>
  <li>I can test my underlying components individually without resorting to network connectivity.</li>
</ul>

<p>Cons:</p>
<ul>
  <li>This is a complex client that will take time to learn fully.</li>
  <li>Offline can introduce caching bugs (such as stale data) that just didn’t exist before.</li>
  <li>I have to wrap a good portion of my app in the Apollo client, replacing the Flux implementation (or at least making it harder to implement and follow the data flow).</li>
</ul>

<h2 id="wrap-up">Wrap Up</h2>

<p>Here is the basic version that covers the advice I would give as of this writing:</p>

<ul>
  <li>Use the Apollo Client with the AWS AppSync SDK if you need offline capabilities.</li>
  <li>Wrap your component in the AWS Amplify Connect component for the majority of online-only cases, then use <code class="highlighter-rouge">API.graphql()</code> for the mutations to send data to the server.</li>
  <li>Use <code class="highlighter-rouge">API.graphql()</code> only if you want to do a query outside of a React component.</li>
  <li>Keep an eye on the AWS Amplify library as they are always extending the functionality of the client.</li>
</ul>

<!-- AWS Links -->

<!-- Consoles -->

<!-- My Links -->
:ET