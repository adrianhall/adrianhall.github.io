I"a<p>I am currently developing a “restaurant reviews” app, written in React Native and using a suite of services surrounding <a href="https://aws.amazon.com/appsync">AWS AppSync</a> for the data backend. Yesterday, I ran into a problem. This is how I solved that problem.</p>

<p>First, let’s take a look at the problem. I have a query that is submitted like this:</p>

<div class="language-graphql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="n">me</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="n">id</span><span class="w">
    </span><span class="n">name</span><span class="w">
    </span><span class="n">locations</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">totalCount</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="n">reviews</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">totalCount</span><span class="w"> </span><span class="p">}</span><span class="w">
    </span><span class="n">favorites</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">totalCount</span><span class="w"> </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>The query is used to generate a header on a “My Information” page. Eventually, I’ll add other things to this query, but this is representative of the problem. Most of the items within this query are easily achieved. The ID comes from the Amazon Cognito authentication; the name comes from an Amazon DynamoDB lookup, and the counts of locations and reviews comes from an ElasticSearch query.</p>

<p>The favorites resolver is a little different. It is actually a combination of two functions that are executed in sequence. The first function uses an ElasticSearch query to get the total count and a list of IDs that are favorites. The second function uses a DynamoDB <code class="highlighter-rouge">BatchGetItem</code> to load the data for those favorites.</p>

<p>The function in question (<code class="highlighter-rouge">getLocationForList</code>) has a request mapping template:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#set($keys = [])
#foreach($id in ${ctx.prev.result.ids})
    #set($key = {})
    $util.qr($key.put("typeName", $util.dynamodb.toString("LOCATION")))
    $util.qr($key.put("id", $util.dynamodb.toString($id)))
    $util.qr($keys.add($key))
#end

{
    "version": "2018-05-29",
    "operation" : "BatchGetItem",
    "tables" : {
        "devRestaurantReviews": {
            "keys": $util.toJson($keys),
        }
    }
}
</code></pre></div></div>

<p>Here, <code class="highlighter-rouge">$ctx.prev.result</code> is the result of the prior step of the pipeline resolver. Here is the associated response mapping template:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>## Raise a GraphQL field error in case of a datasource invocation error
#if($ctx.error)
    $util.error($ctx.error.message, $ctx.error.type)
#end

#set($result = {})
$util.qr($result.put("totalCount", $ctx.prev.result.totalCount))
$util.qr($result.put("nextToken",$ctx.prev.result.nextToken))
$util.qr($result.put("items", $ctx.result.data.devRestaurantReviews))
$util.toJson($result)
</code></pre></div></div>

<p>Again, <code class="highlighter-rouge">$ctx.prev.result</code> is the results from the prior step in the pipeline resolver (the one that gets the paged response), and <code class="highlighter-rouge">$ctx.result</code> is the results of the current step in the pipeline resolver (the one that resolves the list of IDs into complete objects).</p>

<h2 id="so-whats-the-problem">So, what’s the problem?</h2>

<p>The problem comes when a user first enters the app. They don’t have any favorites in the list. As a result, <code class="highlighter-rouge">$ctx.prev.result.ids</code> is zero length. When the resolver tries to do <code class="highlighter-rouge">BatchGetItem</code>, the following error will be generated:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Object {
  "data": null,
  "errorInfo": null,
  "errorType": "MappingTemplate",
  "locations": Array [
   Object {
     "column": 5,
     "line": 11,
     "sourceName": null,
   },
  ],
  "message": "RequestItem keys '$[tables][devRestaurantReviews]' can't be empty",
  "path": Array [
    "me",
    "favorites",
  ],
},
</code></pre></div></div>

<p>The error is pretty clear. The list of IDs we are feeding into the BatchGetItem is empty, and it isn’t allowed to be empty.</p>

<h2 id="how-do-we-fix-it">How do we fix it?</h2>

<p>To fix this, I need to introduce you to a new VTL directive: <a href="https://docs.aws.amazon.com/appsync/latest/devguide/resolver-util-reference.html#aws-appsync-directives"><code class="highlighter-rouge">#return</code></a>. The <code class="highlighter-rouge">#return</code> directive will exit out from the resolver, returning whatever you decide. You can also use <code class="highlighter-rouge">#return</code> on its own (with no argument) to return null.</p>

<p>Using <code class="highlighter-rouge">#return</code> in a mapping template of a function will return that data from the function. If you use it within a request mapping template, the response mapping template is bypassed. Similarly, using <code class="highlighter-rouge">#return</code> in a mapping template of a resolver will return that data from the resolver, prematurely ending the resolver execution.</p>

<p>My fix, then, is to alter the request mapping template such that it uses #return when the number of IDs is zero. Since VTL is based within Java and I am using an array, I can use the Java Array methods to find out information about the array. In this case, I can use <code class="highlighter-rouge">.size()</code> to determine the size of the array:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#if($ctx.prev.result.ids.size() == 0) 
  #set($result = {})
  $util.qr($result.put("totalCount", $ctx.prev.result.totalCount))
  $util.qr($result.put("nextToken",$ctx.prev.result.nextToken))
  $util.qr($result.put("items", $ctx.prev.result.ids))
  #return($result)
#end

#set($keys = [])
#foreach($id in ${ctx.prev.result.ids})
    #set($key = {})
    $util.qr($key.put("typeName", $util.dynamodb.toString("LOCATION")))
    $util.qr($key.put("id", $util.dynamodb.toString($id)))
    $util.qr($keys.add($key))
#end

{
    "version": "2018-05-29",
    "operation" : "BatchGetItem",
    "tables" : {
        "devRestaurantReviews": {
            "keys": $util.toJson($keys),
        }
    }
}
</code></pre></div></div>

<p>Note that I did not have to adjust the schema to accommodate this change in behavior. The front end can and should be isolated from the concerns of the backend data plane. Also, unlike most “responses”, I don’t convert to JSON - I just return the object that I want to return as the result.</p>

<p>The Velocity Template Language is incredibly powerful. Combined with pipeline resolvers, I would be hard pressed to find a situation that cannot be modeled with AWS AppSync.</p>

<!-- AWS Links -->

<!-- Consoles -->

<!-- My Links -->
:ET