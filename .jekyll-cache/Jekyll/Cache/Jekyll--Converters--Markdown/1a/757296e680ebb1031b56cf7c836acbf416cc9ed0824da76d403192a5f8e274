I"ßz<p>Creating a functional GraphQL API is hard. You have to create a GraphQL schema, decide on authentication and database structures, implement the schema in a GraphQL service, wire up the authentication, hook up the database sources, ensure the whole thing is scalable, worry about logging and monitoring, and then write your app.</p>

<p><a href="https://aws.amazon.com/appsync">AWS AppSync</a> helps you with everything except the GraphQL schema and the app. Now, <a href="https://aws-amplify.github.io?utm_source=da&amp;utm_medium=blog&amp;utm_campaign=adrianha">AWS Amplify</a> is helping you with the GraphQL schema by introducing model transforms. This is an open-source library that transforms an annotated GraphQL schema into a real GraphQL schema that you can deploy (technically, the schema is embedded in an [AWS CloudFormation]  <a href="https://aws.amazon.com/cloudformation/aws-cloudformation-templates/">template</a> that can be deployed on AWS). If you are using the AWS Amplify CLI (and you should‚Ää‚Äî‚Ääit makes the process much easier), it will also deploy all the resources necessary to implement the GraphQL schema on AWS AppSync and wire them up with appropriate VTL mapping templates to properly do the operations.</p>

<p>Let‚Äôs take a little example. I use my notes app as my go-to teaching tool. It uses one table‚Ää‚Äî‚Ääa list of notes. I can represent this in standard GraphQL schema language like this:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">Query</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">getNote</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!):</span><span class="w"> </span><span class="n">Note</span><span class="w">
  </span><span class="n">listNotes</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">Note</span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">Mutation</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">createNote</span><span class="p">(</span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!,</span><span class="w"> </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!):</span><span class="w"> </span><span class="n">Note</span><span class="w">
  </span><span class="n">updateNote</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!,</span><span class="w"> </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!,</span><span class="w"> </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!):</span><span class="w"> </span><span class="n">Note</span><span class="w">
  </span><span class="n">deleteNote</span><span class="p">(</span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!):</span><span class="w"> </span><span class="n">Note</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">schema</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">query</span><span class="w"> </span><span class="n">Query</span><span class="w">
  </span><span class="n">mutation</span><span class="w"> </span><span class="n">Mutation</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Of course, this isn‚Äôt ‚Äúbest practices‚Äù. It‚Äôs probably very similar to the first GraphQL schema just about everyone who is learning the schema language writes. We do basic CRUD operations and don‚Äôt worry about searching, sorting, pagination, input types, or subscriptions. Those things can be added on later.</p>

<p>With an annotated schema, we can write the following:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Yep‚Ää‚Äî‚Ääthat‚Äôs it. Just five lines. What happens when you run it through the model transforms library (and deploy it via the AWS Amplify CLI) is that this is expanded. You get a CRUD API with paging and filtering built-in; input types are created for each of the mutations and subscriptions are set up on each mutation; the backing store in a DynamoDB database. Five lines turns into over 100 lines of schema that will take care of most of the requirements of your typical app.</p>

<p>The <code class="highlighter-rouge">@model</code> is an annotation that tells the model transform library to do something. There are a big list of them, but basically, they fall into three camps:</p>

<ul>
  <li>Backing or data store directives</li>
  <li>Authorization directives</li>
  <li>Capabilities directives</li>
</ul>

<h2 id="backing-data-store">Backing Data Store</h2>

<p>I‚Äôve already introduced you to one data store directive in my example above. The <code class="highlighter-rouge">@model</code> directive stores the data in a table dedicated to the type within <a href="https://aws.amazon.com/dynamodb">Amazon DynamoDB</a>. This is good for basic searches and filtering, but you may want better searchability of your data. For example, you might want to do geo-lookups, or faceted search. For this sort of functionality, it would be a good idea to stream the data from DynamoDB to an ElasticSearch Service. To do that, add the @searchable directive to the type:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Note</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w"> </span><span class="err">@</span><span class="n">searchable</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Underneath the covers, <a href="https://aws-amplify.github.io?utm_source=da&amp;utm_medium=blog&amp;utm_campaign=adrianha">AWS Amplify</a> deploys a DynamoDB table and an ElasticSearch Service instance with an <a href="https://aws.amazon.com/lambda">AWS Lambda</a> function that streams data from DynamoDB to ElasticSearch. All the queries will hit the ElasticSearch Service and all the mutations will be sent to DynamoDB.</p>

<h2 id="authorization">Authorization</h2>

<p>Before model transforms, you needed to adjust the VTL-based mapping templates to properly implement authorization within the API. The model transforms library makes authorization a breeze. Let‚Äôs say I wanted to change my note into a multi-tenant service. Here is how I would do it:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Note</span><span class="w">
    </span><span class="err">@</span><span class="n">model</span><span class="w">
    </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="n">rules</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">{</span><span class="w"> </span><span class="n">allow</span><span class="err">:</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="err">}</span><span class="p">])</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>The <code class="highlighter-rouge">@auth</code> directive provides rules to say who can access the specific type operations. These can get quite complex. Note that the rules is a JSON array of individual rules. Each rule can have several components, the only one of which is required is the allow field.</p>

<p>Let‚Äôs take a slightly more complex version of this. Let‚Äôs say you wanted to allow the owner to create, update, and delete their own notes, but you wanted the owner and a group of people called ‚Äúmanagers‚Äù to read the notes:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Note</span><span class="w">
  </span><span class="err">@</span><span class="n">model</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="n">rules</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="err">{</span><span class="w"> </span><span class="n">allow</span><span class="err">:</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="err">}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="w"> </span><span class="n">allow</span><span class="err">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="err">:</span><span class="w"> </span><span class="err">["</span><span class="n">managers</span><span class="err">"</span><span class="p">],</span><span class="w"> </span><span class="n">queries</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="w"> </span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
    </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
    </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
    </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>If any auth rule matches, then the operation is allowed. Here is a list of all the things you can currently set:</p>

<ul>
  <li>The <code class="highlighter-rouge">allow</code> field is required and can be ‚Äúowner‚Äù or ‚Äúgroups‚Äù</li>
  <li>The <code class="highlighter-rouge">ownerField</code> is the field where the owner of the record is stored. This defaults to the field name <code class="highlighter-rouge">owner</code>.</li>
  <li>The <code class="highlighter-rouge">identityField</code> is the field within the <code class="highlighter-rouge">$context.identity</code> object within the VTL that you store in the ownerField to recognize the owner. It defaults to <code class="highlighter-rouge">username</code>.</li>
  <li>The <code class="highlighter-rouge">groupsField</code> is the field within record that provides the group information that is compared.</li>
  <li>The <code class="highlighter-rouge">groups</code> field is the list of groups to allow when the <code class="highlighter-rouge">allow</code> field is set to <code class="highlighter-rouge">groups</code>. This field can be a string or an array of strings if you want to represent multiple groups.</li>
  <li>The <code class="highlighter-rouge">mutations</code> field is the list of mutations to allow. This field is always an array and can consist of zero or more of ‚Äúcreate‚Äù, ‚Äúupdate‚Äù or ‚Äúdelete‚Äù.</li>
  <li>The <code class="highlighter-rouge">queries</code> field is the list of queries to allow. This field is (as with the mutations), an array and consists of zero or more of ‚Äúget‚Äù and ‚Äúlist‚Äù.</li>
</ul>

<p>If you don‚Äôt specify any queries or mutations, then it assumes all of the available operations are handled by the rule. If even one query or mutation is listed, then it assumes the others are not allowed by the rule.</p>

<p>I fully expect this area to get much richer as time goes by to support more and more authorization scenarios.</p>

<h2 id="capabilities">Capabilities</h2>

<p>To show off capabilities, let‚Äôs take a different model. Let‚Äôs say I have a blog application where multiple people can have a blog. Each blog can have a number of posts, and each post can have a number of comments. This may seem a little contrived, but relationships between types is common. Most applications will implement this with a SQL database and represent the types as individual tables that can be joined.</p>

<p>With GraphQL, you get cascading resolvers instead, so you don‚Äôt need to program in complex SQL queries to manage this for you. However, you need to model the data. For this, you can use the <code class="highlighter-rouge">@connection</code> directive. Let‚Äôs take a look at the blog example:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Blog</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="err">[</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">owners</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">mutations</span><span class="err">["</span><span class="n">create</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">update</span><span class="err">"}]}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">everyone</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">queries</span><span class="p">:[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">posts</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">Post</span><span class="p">]</span><span class="w"> </span><span class="err">@</span><span class="n">connection</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">Post</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w"> </span><span class="err">@</span><span class="n">searchable</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="err">[</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="err">}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">everyone</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">queries</span><span class="p">:[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">comments</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">Comment</span><span class="p">]</span><span class="w"> </span><span class="err">@</span><span class="n">connection</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">Comment</span><span class="w">
  </span><span class="err">@</span><span class="n">model</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="err">[</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="err">}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">everyone</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">queries</span><span class="p">:[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>The <code class="highlighter-rouge">@connection</code> supports both one-to-one and one-to-many relationships. There is a little bit more to do if you want the bi-directional connections to provide reverse linkage. For example, if you wanted to say ‚Äúgive me all the posts for a particular blog‚Äù, you may want the bi-directional linkage. You can do this by naming the connection:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Blog</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="err">[</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">owners</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">mutations</span><span class="err">["</span><span class="n">create</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">update</span><span class="err">"}]}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">everyone</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">queries</span><span class="p">:[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">posts</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">Post</span><span class="p">]</span><span class="w"> </span><span class="err">@</span><span class="n">connection</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="err">"</span><span class="n">BlogPosts</span><span class="err">"</span><span class="p">)</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="k">type</span><span class="w"> </span><span class="n">Post</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w"> </span><span class="err">@</span><span class="n">searchable</span><span class="w">
  </span><span class="err">@</span><span class="n">auth</span><span class="p">(</span><span class="err">[</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">owner</span><span class="w"> </span><span class="err">}</span><span class="p">,</span><span class="w">
    </span><span class="err">{</span><span class="n">allow</span><span class="p">:</span><span class="w"> </span><span class="n">groups</span><span class="p">,</span><span class="w"> </span><span class="n">groups</span><span class="p">:</span><span class="err">"</span><span class="n">everyone</span><span class="err">"</span><span class="p">,</span><span class="w"> </span><span class="n">queries</span><span class="p">:[</span><span class="err">"</span><span class="n">get</span><span class="err">"</span><span class="p">,</span><span class="err">"</span><span class="n">list</span><span class="err">"</span><span class="p">]</span><span class="err">}</span><span class="w">
  </span><span class="err">]</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">blog</span><span class="p">:</span><span class="w"> </span><span class="n">Blog</span><span class="w"> </span><span class="err">@</span><span class="n">connection</span><span class="p">(</span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="err">"</span><span class="n">BlogPosts</span><span class="err">"</span><span class="p">)</span><span class="w">
  </span><span class="n">comments</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="n">Comment</span><span class="p">]</span><span class="w"> </span><span class="err">@</span><span class="n">connection</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Use the same name in both sides of the connection (one in the <code class="highlighter-rouge">Blog</code> type and one in the <code class="highlighter-rouge">Post</code> type).</p>

<p>Another good capability to add is versioning. This is especially useful when you are using the interface for an fully offline scenario when you need object versioning and conflict detection. In this scenario, when you send an update, you must also send a version field. This says ‚ÄúI‚Äôm updating record with id X and version Y‚Äù. If the current version doesn‚Äôt match Y, then a conflict response is produced. You can use this on the client to produce the correct dialog. Here is my original Notes type with versioning:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Notes</span><span class="w"> </span><span class="err">@</span><span class="n">model</span><span class="w"> </span><span class="err">@</span><span class="n">versioned</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">id</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>The current version is stored in a field called <code class="highlighter-rouge">version</code>. When you send an update or delete, send an <code class="highlighter-rouge">expectedVersion</code> field as well to handle conflict resolution.</p>

<p>Note that most of the directives (<code class="highlighter-rouge">@connection</code>, <code class="highlighter-rouge">@auth</code>, <code class="highlighter-rouge">@versioned</code>, and <code class="highlighter-rouge">@searchable</code>) currently rely on DynamoDB as the backing store, so they require the <code class="highlighter-rouge">@model</code> directive to be added to the type.</p>

<p>You can use the GraphQL transforms library independently of the AWS Amplify CLI as well. It produces a CloudFormation template that has the schema, resolver mapping templates, and resource descriptions that are needed to implement the transformed GraphQL API in <a href="https://aws.amazon.com/appsync">AWS AppSync</a>. Check out <a href="https://github.com/aws-amplify/amplify-cli/tree/master/packages/graphql-transformer-core">the documentation</a> if you want to try that out.</p>

<h2 id="conclusion">Conclusion</h2>

<p><a href="https://aws-amplify.github.io?utm_source=da&amp;utm_medium=blog&amp;utm_campaign=adrianha">AWS Amplify</a> is all about making you more productive as a front-end developer, and the GraphQL model transforms is one step in that process. Check out the other components‚Ää‚Äî‚Ääthe AWS Amplify CLI for easily deploying web and mobile serverless backends and the AWS Amplify library for JavaScript to easily use the serverless backend you have set up. GraphQL has a relatively larger learning curve (compared to, say, REST), but it comes with a lot of power. Model transforms enables you to short circuit that learning curve so that you can get on with writing your app.</p>

<!-- AWS Links -->

<!-- Consoles -->

<!-- My Links -->

:ET