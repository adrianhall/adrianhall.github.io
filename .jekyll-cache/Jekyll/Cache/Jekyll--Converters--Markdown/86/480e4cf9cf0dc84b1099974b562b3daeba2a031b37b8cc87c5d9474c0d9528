I"Š4<blockquote>
  <p>AWS AppSync provides four distinct methods of authorizing users to optimize and restrict data being transferred</p>
</blockquote>

<p><a href="https://aws.amazon.com/appsync">AWS AppSync</a> is a managed <a href="https://graphql.org/learn">GraphQL</a> data service that supports offline and real-time scenarios. The service allows the developer to optimize the data transfer between client and server.</p>

<p>Any non-trivial application will need to authenticate users. Itâ€™s the only way to identify a distinct real person using the application. That association is required for private data storage and compliance reasonsâ€Šâ€”â€Šfor example, GDPR includes <a href="https://gdpr-info.eu/art-17-gdpr/">a right of erasure</a>.</p>

<p>Developers will also have to manage data that is associated with an individual, group or role and operations with that data must be restrictedâ€Šâ€”â€Šthatâ€™s authorization. In short, you need both authentication and authorization.</p>

<p>AWS AppSync provides four distinct methods of authorizing users:</p>

<ul>
  <li>API key</li>
  <li>OpenID Connect (OIDC)</li>
  <li>Amazon Cognito user pools</li>
  <li>AWS Identity and Access Management (IAM)</li>
</ul>

<p>In addition, each option has several parameters that you can set to ensure that you get the right authorization for each query and mutation that an app can execute. So, which method do you use?</p>

<h2 id="api-key">API Key</h2>

<p>You shouldnâ€™t use API keys for user authorization in a production app because thereâ€™s no concept of identity. Under most circumstances, developers should only leverage an API key when youâ€™re building a read-only public-facing applicationâ€Šâ€”â€Šor in the prototyping phase of your application development cycle. After prototyping, you can switch to a different authorization method.</p>

<p>You can use any client that supports HTTPS transport with an API key. Just add an <code class="highlighter-rouge">X-API-KEY</code> header to each request. The value of the header should be the API key. When you choose this option, the API key is listed within the AWS AppSync settings.</p>

<h2 id="openid-connect-oidc">OpenID Connect (OIDC)</h2>

<p>Use OIDC if you need to integrate with a pre-existing identity provider and donâ€™t want to do federationâ€Šâ€”â€Š<em>more on that later</em>.</p>

<p>OIDC allows you to work with users by passing a JSON Web Token (JWT) token as an authorization header in the HTTPS request. You can use any GraphQL client that supports adding a header to the HTTPS request.</p>

<p>You can be more granular with authorization by filtering on the claims in the token (which are available through <code class="highlighter-rouge">$context.identity.claims</code>) in the VTL-based resolver templates. However, thereâ€™s no real notion of â€œgroupsâ€ or â€œrolesâ€ unless theyâ€™re added as claims by the third-party provider.</p>

<p>If you want to store data thatâ€™s associated with the user, ensure that you choose a claim that doesnâ€™t change when the user changes their information. Usually, <code class="highlighter-rouge">$context.identity.sub</code> is a good choice, but thatâ€™s not a guarantee.</p>

<h2 id="amazon-cognito-user-pools">Amazon Cognito user pools</h2>

<p>Using an Amazon Cognito user pool is perhaps the most flexible option, so I recommend using this option if you have no other authentication source and youâ€™re setting up everything from scratch.</p>

<p>A user pool is an OIDC-compliant authentication provider with some additional benefitsâ€Šâ€”â€Šsuch as group functionality. So you can use any GraphQL client that allows you to alter the headers of the request. Add a bearer authorization header to each request to authenticate the user.</p>

<p>AWS AppSync has built-in support for the specifics of user pools. The main thing that you can do with user pools that you canâ€™t do with generic OIDC authentication is to organize users into groups.</p>

<p>User pools support direct federation with Facebook and Google authentication providers. This allows you to do single sign-on with those environments. For federating with other providers, check out AWS IAM as a source.</p>

<p>Integrating your app with a user pool is easy. The AWS Mobile SDK provides pre-built screens for iOS (Objective-C and Swift) and Android (Java and Kotlin). AWS Amplify provides support for React Native and single-page applications that are written with React and Angular. There are also low-level interfaces for most environments if you want to generate your own authentication screens.</p>

<p>Iâ€™ll be talking more about user pools a little laterâ€Šâ€”â€Š<em>so stay tuned</em>!</p>

<h2 id="identity-access-management-iam">Identity Access Management (IAM)</h2>

<p>The final authorization method that you can use is IAM. This is a good option if you have an existing Amazon Cognito identity pool (identity pools are also known as federated identities), or if youâ€™ve created an access key and secret key for the application. The access permissions are handled by IAM roles.</p>

<p>An identity pool can federate with a wide variety of authentication providersâ€Šâ€”â€Šincluding Facebook, Google, user pools, and any other OIDC or SAML provider, including Active Directory Federated Services (AD FS). Using IAM is also the only current method that allows both unauthenticated and authenticated requests within the same API.</p>

<p>To use IAM, the request must be signed with AWS Signature Version 4. Most clients donâ€™t support AWS Signature Version 4 out of the box. That limits you to the Apollo client with the AWS AppSync transport, the AWS Amplify client, and the AWS Mobile SDK for iOS and Android.</p>

<h2 id="options-for-amazon-cognito-user-pools">Options for Amazon Cognito user pools</h2>

<p>You can see why I prefer using an Amazon Cognito user poolâ€Šâ€”â€Šitâ€™s the most flexible of the options Iâ€™ve described. Developers can use any GraphQL client, provide group-based authorization rules with fine-grained access to claims from the directory, and federate with Facebook and Google. Thereâ€™s a lot of reasons to recommend this option.</p>

<p>Authorization is split into three distinct phases:</p>

<ol>
  <li>First, the schema is consulted for <code class="highlighter-rouge">@aws_auth</code> directives. If the user is a member of a listed group, then the operation is allowed.</li>
  <li>If thereâ€™s no <code class="highlighter-rouge">@aws_auth</code> directive, then the global setting (<code class="highlighter-rouge">ALLOW</code> or <code class="highlighter-rouge">DENY</code>) is used as the permission.</li>
  <li>You can also specify (fine-grained access control) rules within the VTL request or response resolver to return <code class="highlighter-rouge">$util.unauthorized()</code> for more specific authorization rules.</li>
</ol>

<p>Most APIs use <code class="highlighter-rouge">ALLOW</code> as the default action. That means that a user can access the API unless theyâ€™re explicitly prevented from doing so by an <code class="highlighter-rouge">@aws_auth</code> directive.</p>

<p>The alternative is <code class="highlighter-rouge">DENY</code>, which means that you must be explicitly allowed to do something by using an <code class="highlighter-rouge">@aws_auth</code> directive. (This really means that every single query and mutation must have an <code class="highlighter-rouge">@aws_auth</code> directive, and every user must belong to a group.)</p>

<p>Letâ€™s use an example of writing a blogging platform. We might define a blog as follows:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Post</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">postId</span><span class="p">:</span><span class="w"> </span><span class="nb">ID</span><span class="p">!</span><span class="w">
  </span><span class="n">author</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
  </span><span class="n">category</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>Weâ€™ll want public access to the blog, sol letâ€™s set the default permission to <code class="highlighter-rouge">ALLOW</code>. However, we also want special permissions on the <code class="highlighter-rouge">addPost()</code> mutation. Only members of the <code class="highlighter-rouge">editors</code> group, which weâ€™ve defined inside our user pool, can post things:</p>

<figure class="highlight"><pre><code class="language-graphql" data-lang="graphql"><span class="k">type</span><span class="w"> </span><span class="n">Mutation</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="n">addPost</span><span class="p">(</span><span class="n">title</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!,</span><span class="w"> </span><span class="n">content</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!,</span><span class="w"> </span><span class="n">category</span><span class="p">:</span><span class="w"> </span><span class="nb">String</span><span class="p">!):</span><span class="w"> </span><span class="n">Post</span><span class="w">
  </span><span class="err">@</span><span class="n">aws_auth</span><span class="p">(</span><span class="n">cognito_groups</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="err">"</span><span class="n">editors</span><span class="err">"</span><span class="p">])</span><span class="w">
</span><span class="p">}</span></code></pre></figure>

<p>In addition, weâ€™ll want a separate setting so that only users in the <code class="highlighter-rouge">announcements</code> group, another group weâ€™ve defined inside our user pool, can post to the <code class="highlighter-rouge">Announcements</code> category. This is done inside the request resolver:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#foreach($group in $ctx.identity.claims.get("cognito:groups"))
#if($group == "announcements")
#set($inAnnouncementsGroup = true)
#end
#end
#if(($ctx.args.category=="Announcement" &amp;&amp; $inAnnouncementsGroup == true) || ($ctx.args.category != "Announcement"))
{
  â€œversionâ€: â€œ2017â€“02â€“28â€,
  â€œoperationâ€: â€œPutItemâ€,
  â€œkeyâ€: {
    â€œpostIdâ€: { â€œSâ€ : â€œ$utils.autoId()â€ }
  },
  â€œattributeValuesâ€: {
    â€œownerâ€: { â€œSâ€ : â€œ${ctx.identity.sub}â€ },
    â€œtitleâ€ : { â€œSâ€ : â€œ${ctx.args.title}â€ },
    â€œcontentâ€: { â€œSâ€: â€œ${ctx.args.content}â€ },
    â€œcategoryâ€: { â€œSâ€ : â€œ${ctx.args.category}â€ }
  }
}
#else
$utils.unauthorized()
#endif
</code></pre></div></div>

<p>The first few lines determine if the user is within the right group. Developers can do any checks we want here. For example, these checks might be verifying that the user is within the corporate network, or that the user has a specific claim within the directory.</p>

<p>The next step is to decide if the user is allowed to do the query. If they are allowed, then perform the operation. Otherwise, return unauthorized.</p>

<h2 id="filtering-on-app-clients">Filtering on app clients</h2>

<p>Both the OIDC provider and the user pools provider have the option to specify an AppId client regular expression. This allows you to allow (or block) requests to the API based on the app client ID.</p>

<p>The app client is defined within the OIDC provider or the Amazon Cognito console. The easiest way to use it is to provide an ORâ€™ed list of allowed AppIdâ€™sâ€Šâ€”â€Šbecause they donâ€™t tend to be easily digested by a regular expression.</p>

<p>Why would you even use this? Well, letâ€™s say you have a set of clients for mobile apps (one for Android, one for iOS, one for web, and so on) and a set of clients for server-side operations. You might want to prevent the clients for server-side operations from using the GraphQL APIâ€Šâ€”â€Šfollowing the principal of providing the least access. You might also want to deprecate clients over time. You can control this by filtering as well.</p>

<h2 id="summary">Summary</h2>

<p>AWS AppSync offers authentication and authorization options that provide a lot of flexibility. The AWS AppSync team is constantly evolving the authorization capabilities, so itâ€™s worth looking at the latest options.</p>

<p>I highly recommend reading the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/security-authorization-use-cases.html">authorization use cases documentation</a> in the <a href="https://docs.aws.amazon.com/appsync/latest/devguide/welcome.html">AWS AppSync Developer Guide</a> next, as that document shows off a lot of the power of the AWS AppSync service.</p>

<!-- AWS Links -->

<!-- Consoles -->

<!-- My Links -->

:ET